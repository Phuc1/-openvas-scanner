use std::{collections::HashMap, fmt::Display, io::Cursor};

use rocket::{http::Status, response::Responder, serde::json::Json, Request, Response};
use serde::{Deserialize, Serialize};

/// Errors, that might occur during request processing
#[derive(Serialize, Deserialize, Debug)]
pub enum APIError {
    /// The given body does not contain a valid JSON String
    BadJsonError {
        /// Error message generated by serde
        message: String,
    },
    /// The given JSON cannot be parsed correctly because of incorrect fields
    ParseJsonError {
        /// Error message generated by serde
        message: String,
        /// The erroneous fields with a description of the error
        field_errors: HashMap<String, String>,
    },
    /// A requested resource was not found
    ResourceNotFound {
        /// Error message
        message: String,
        /// ID of the requested resource
        id: String,
    },
    /// Cannot create a resource, that already exists
    ResourceExists {
        /// Error message
        message: String,
        /// ID of the existing resource
        id: String,
    },
    /// Cannot parse the quarry parameters
    ParseQueryError {
        /// Error message
        message: String,
        /// The erroneous parameter with a description of the error
        field_errors: HashMap<String, String>,
    },
    /// A resource is in a different state, that is needed for the requested action
    BadResourceState {
        /// Error message
        message: String,
        /// Expected state to perform the action
        expected: Vec<String>,
        /// Current state of the resource
        got: String,
    },
    /// The requested action is not implemented
    ActionNotSupported {
        /// Error message
        message: String,
        /// Available actions
        available: Vec<String>,
        /// Requested action
        got: String,
    },
}

impl Display for APIError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadJsonError { message } => write!(f, "{message}"),
            Self::ParseJsonError { message, .. } => write!(f, "{message}"),
            Self::ResourceNotFound { message, .. } => write!(f, "{message}"),
            Self::ResourceExists { message, .. } => write!(f, "{message}"),
            Self::ParseQueryError { message, .. } => write!(f, "{message}"),
            Self::BadResourceState { message, .. } => write!(f, "{message}"),
            Self::ActionNotSupported { message, .. } => write!(f, "{message}"),
        }
    }
}

impl<'r> Responder<'r, 'static> for APIError {
    fn respond_to(self, _: &'r Request<'_>) -> rocket::response::Result<'static> {
        let msg = Json(&self).to_string();
        let mut resp = Response::new();
        resp.set_sized_body(msg.len(), Cursor::new(msg));
        match self {
            Self::BadJsonError { .. } => resp.set_status(Status::BadRequest),
            Self::ParseJsonError { .. } => resp.set_status(Status::BadRequest),
            Self::ResourceNotFound { .. } => resp.set_status(Status::NotFound),
            Self::ResourceExists { .. } => resp.set_status(Status::BadRequest),
            Self::ParseQueryError { .. } => resp.set_status(Status::BadRequest),
            Self::BadResourceState { .. } => resp.set_status(Status::NotAcceptable),
            Self::ActionNotSupported { .. } => resp.set_status(Status::NotImplemented),
        };
        Ok(resp)
    }
}
