// SPDX-FileCopyrightText: 2023 Greenbone AG
//
// SPDX-License-Identifier: GPL-2.0-or-later

use std::{path::PathBuf, io::Read, fmt::Display, fs::File};

use models::{Vulnerability, VulnerabilityData};
use nasl_syntax::{LoadError, Loader, AsBufReader, FSPluginLoader};
use notus::loader::{hashsum::HashsumAdvisoryLoader, AdvisoryLoader};
use storage::{Dispatcher, Kb};

use crate::{CliError, CliErrorKind};

pub fn run<'a, S>(storage: S, path: PathBuf, signature_check: bool) -> Result<(), CliError>
where
    S: Sync + Send + Dispatcher<String>,
{
    
    let loader = FSPluginLoader::new(path.to_string_lossy().to_string());
    let advisories_files = match HashsumAdvisoryLoader::new(loader.clone()) {
        Ok(loader) => loader,
        Err(_) => {
            return Err(CliError {
                filename: "".to_string(),
                kind: CliErrorKind::LoadError(LoadError::Dirty("Problem loading advisory".to_string()))
            })
        }
    };

    advisories_files.verify_signature();
    for f in advisories_files.get_advisories().unwrap().iter() {
        let filename = format!("{}.notus", f);
        println!("file name {f:?}");
        let _advisory_file = loader.clone().load(f);
        let advisories = advisories_files.load_advisory(f).unwrap();

        for adv in advisories.iter() {
            let key = format!("internal/notus/advisories/{}", adv.oid);
            println!("file name {:?}", key);
            let value = Vulnerability::from(
                &VulnerabilityData {
                    adv: &adv,
                    product_data: &advisories,
                    filename: &filename,
                }
            );

            let serialized = serde_json::to_string(&value).unwrap();
            println!("{:?} = {:?} \n\n ", key, serialized);
            
            let _ = storage.dispatch(&key, storage::Field::NOTUS(Kb{key: "key 1".to_string(), value: serialized.into(), expire: None}) );
            
        }
    }    
    
    println!("AAAAAAAAAA");
    
    Ok(())
}
